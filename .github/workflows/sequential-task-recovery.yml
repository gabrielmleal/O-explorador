name: Sequential Task Recovery

on:
  workflow_dispatch:
    inputs:
      recovery_action:
        description: 'Recovery action to perform'
        required: true
        type: choice
        options:
          - 'status'
          - 'recover'
          - 'reset'
        default: 'status'
      resume_from_task:
        description: 'Task index to resume from (0-based, optional for recover action)'
        required: false
        type: string
      confirm_reset:
        description: 'Type "RESET" to confirm complete reset (required for reset action)'
        required: false
        type: string

jobs:
  recovery-operation:
    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      issues: write
      actions: write
      id-token: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}

      - name: Perform recovery operation
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
          RECOVERY_ACTION: ${{ github.event.inputs.recovery_action }}
          RESUME_FROM_TASK: ${{ github.event.inputs.resume_from_task }}
          CONFIRM_RESET: ${{ github.event.inputs.confirm_reset }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const path = require('path');
            const recoveryUtils = require(path.join(process.cwd(), 'scripts', 'sequential-task-recovery.js'));
            
            const action = process.env.RECOVERY_ACTION;
            const resumeFromTask = process.env.RESUME_FROM_TASK;
            const confirmReset = process.env.CONFIRM_RESET;
            
            console.log(`üõ†Ô∏è Performing recovery action: ${action}`);
            
            try {
              let result;
              
              switch (action) {
                case 'status':
                  console.log('üìä Getting sequential execution status...');
                  result = recoveryUtils.getSequentialStatus();
                  
                  console.log('=== SEQUENTIAL EXECUTION STATUS ===');
                  console.log(`Overall Status: ${result.overall_status || 'unknown'}`);
                  console.log(`Total Tasks: ${result.total_tasks || 0}`);
                  console.log(`Current Task Index: ${result.current_task_index || 'N/A'}`);
                  console.log(`Completed: ${result.completed_tasks || 0}`);
                  console.log(`Failed: ${result.failed_tasks || 0}`);
                  console.log(`Pending: ${result.pending_tasks || 0}`);
                  console.log(`In Progress: ${result.in_progress_tasks || 0}`);
                  
                  if (result.tasks && result.tasks.length > 0) {
                    console.log('\n=== TASK DETAILS ===');
                    result.tasks.forEach(task => {
                      const icon = task.status === 'completed' ? '‚úÖ' :
                                   task.status === 'failed' ? '‚ùå' :
                                   task.status === 'in-progress' ? 'üîÑ' :
                                   task.status === 'no-changes' ? '‚ö†Ô∏è' : '‚è≥';
                      console.log(`${icon} Task ${task.index + 1}: ${task.title} (${task.status})`);
                      if (task.pr_number) console.log(`    PR: #${task.pr_number}`);
                      if (task.error_message) console.log(`    Error: ${task.error_message}`);
                    });
                  }
                  
                  core.setOutput('status_result', JSON.stringify(result, null, 2));
                  break;
                
                case 'recover':
                  console.log('üîÑ Recovering sequential execution...');
                  const resumeTaskIndex = resumeFromTask ? parseInt(resumeFromTask, 10) : null;
                  
                  if (resumeTaskIndex !== null) {
                    console.log(`   - Resuming from task index: ${resumeTaskIndex}`);
                  } else {
                    console.log('   - Will auto-detect failed/pending task to resume from');
                  }
                  
                  result = await recoveryUtils.recoverSequentialExecution({
                    github,
                    context,
                    core,
                    resumeFromTaskIndex: resumeTaskIndex
                  });
                  
                  console.log('‚úÖ Recovery operation completed');
                  console.log(`   - Status: ${result.status}`);
                  if (result.resumeTaskIndex !== undefined) {
                    console.log(`   - Resumed from task: ${result.resumeTaskIndex + 1}`);
                  }
                  if (result.taskTitle) {
                    console.log(`   - Task title: ${result.taskTitle}`);
                  }
                  
                  core.setOutput('recovery_result', JSON.stringify(result, null, 2));
                  break;
                
                case 'reset':
                  console.log('üóëÔ∏è Resetting sequential execution...');
                  
                  if (confirmReset !== 'RESET') {
                    throw new Error('Reset not confirmed. Please enter "RESET" in the confirm_reset field to proceed.');
                  }
                  
                  console.log('‚ö†Ô∏è CONFIRMED: Proceeding with complete reset');
                  
                  result = await recoveryUtils.resetSequentialExecution({
                    github,
                    context,
                    confirmReset: true
                  });
                  
                  console.log('‚úÖ Reset operation completed');
                  console.log(`   - Status: ${result.status}`);
                  if (result.backupFile) {
                    console.log(`   - Backup file: ${result.backupFile}`);
                  }
                  if (result.totalTasks) {
                    console.log(`   - Previous task count: ${result.totalTasks}`);
                  }
                  
                  core.setOutput('reset_result', JSON.stringify(result, null, 2));
                  break;
                
                default:
                  throw new Error(`Unknown recovery action: ${action}`);
              }
              
              console.log(`üéâ Recovery action '${action}' completed successfully`);
              
            } catch (error) {
              console.log(`‚ùå Recovery action '${action}' failed:`, error.message);
              core.setFailed(`Recovery operation failed: ${error.message}`);
            }

      - name: Upload recovery artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sequential-recovery-${{ github.event.inputs.recovery_action }}-${{ github.run_number }}
          path: |
            .github/sequential-tasks-state*.json
            sequential-tasks-state-backup-*.json
          retention-days: 30

      - name: Create recovery summary
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const action = '${{ github.event.inputs.recovery_action }}';
            const runId = context.runId;
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
            
            let summaryContent = `## üõ†Ô∏è Sequential Task Recovery: ${action.toUpperCase()}
            
            **Action Performed**: ${action}
            **Workflow Run**: [#${context.runNumber}](${runUrl})
            **Timestamp**: ${new Date().toISOString()}
            
            `;
            
            switch (action) {
              case 'status':
                summaryContent += `### Status Check Results
                
                The current status of sequential execution has been retrieved and logged in the workflow output.
                Check the workflow logs for detailed task status information.
                
                **Next Steps**: If you see failed or stuck tasks, you can use the 'recover' action to resume execution.`;
                break;
                
              case 'recover':
                summaryContent += `### Recovery Operation
                
                Sequential execution recovery has been attempted.
                
                **Recovery Details**:
                - Resume from task: ${{ github.event.inputs.resume_from_task || 'Auto-detected' }}
                - Check workflow logs for specific recovery results
                
                **Next Steps**: Monitor the sequential task executor workflow for continued execution.`;
                break;
                
              case 'reset':
                summaryContent += `### Reset Operation
                
                ‚ö†Ô∏è **COMPLETE RESET PERFORMED**
                
                The sequential execution state has been completely reset and backed up.
                
                **What was reset**:
                - Sequential tasks state file removed
                - All task progress cleared
                - Backup file created for recovery if needed
                
                **Next Steps**: You can now start a new sequential execution with fresh context.`;
                break;
            }
            
            summaryContent += `
            
            ${'---'}
            
            ### Available Recovery Actions
            
            - **status**: Check current sequential execution status
            - **recover**: Resume from a failed or stuck task  
            - **reset**: Completely reset sequential execution (with backup)
            
            To run another recovery action, use the "Actions" tab and run this workflow again.`;
            
            console.log('Recovery Summary:');
            console.log(summaryContent);