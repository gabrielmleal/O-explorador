name: Sequential Task Executor

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      task_index:
        description: 'Task index to execute (0-based)'
        required: true
        default: '0'
        type: string
      previous_branch:
        description: 'Previous branch to base from'
        required: false
        default: 'main'
        type: string
      parent_issue:
        description: 'Parent issue number'
        required: true
        type: string

jobs:
  execute-task:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '[SEQUENTIAL-TASK-TRIGGER]') && contains(github.event.comment.body, '@claude'))
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}

      - name: Parse sequential task trigger
        id: parse-trigger
        uses: actions/github-script@v7
        with:
          script: |
            let taskIndex, previousBranch, parentIssue, triggerSource;
            
            if (context.eventName === 'workflow_dispatch') {
              // For manual workflow dispatch, use inputs
              taskIndex = parseInt(context.payload.inputs.task_index || '0');
              previousBranch = context.payload.inputs.previous_branch || 'main';
              parentIssue = parseInt(context.payload.inputs.parent_issue);
              triggerSource = 'manual_workflow_dispatch';
              
              console.log('üñ±Ô∏è Triggered by manual workflow_dispatch');
              console.log(`   - Task index: ${taskIndex}`);
              console.log(`   - Previous branch: ${previousBranch}`);
              console.log(`   - Parent issue: ${parentIssue}`);
              
            } else if (context.eventName === 'issue_comment') {
              // Parse the sequential task trigger comment
              const commentBody = context.payload.comment.body;
              console.log('üí¨ Triggered by issue comment');
              console.log(`   - Comment: ${commentBody}`);
              
              // Extract parameters from comment format: [SEQUENTIAL-TASK-TRIGGER] task_index=1 previous_branch=sequential/task-1 parent_issue=123
              const triggerMatch = commentBody.match(/\[SEQUENTIAL-TASK-TRIGGER\]\s+(.+)/);
              if (!triggerMatch) {
                throw new Error('Invalid sequential task trigger comment format');
              }
              
              const paramString = triggerMatch[1];
              console.log(`   - Parameters: ${paramString}`);
              
              // Parse individual parameters
              const taskIndexMatch = paramString.match(/task_index=(\d+)/);
              const previousBranchMatch = paramString.match(/previous_branch=([^\s]+)/);
              const parentIssueMatch = paramString.match(/parent_issue=(\d+)/);
              
              if (!taskIndexMatch || !previousBranchMatch || !parentIssueMatch) {
                throw new Error('Missing required parameters in sequential task trigger comment');
              }
              
              taskIndex = parseInt(taskIndexMatch[1]);
              previousBranch = previousBranchMatch[1];
              parentIssue = parseInt(parentIssueMatch[1]);
              triggerSource = 'sequential_task_comment';
              
              console.log('‚úÖ Parsed trigger parameters:');
              console.log(`   - Task index: ${taskIndex}`);
              console.log(`   - Previous branch: ${previousBranch}`);
              console.log(`   - Parent issue: ${parentIssue}`);
              
              // Verify this comment is on the correct issue
              if (context.payload.issue.number !== parentIssue) {
                throw new Error(`Comment posted on wrong issue. Expected: ${parentIssue}, Actual: ${context.payload.issue.number}`);
              }
            } else {
              throw new Error(`Unsupported event type: ${context.eventName}`);
            }
            
            // Set outputs for next steps
            core.setOutput('task_index', taskIndex.toString());
            core.setOutput('previous_branch', previousBranch);
            core.setOutput('parent_issue', parentIssue.toString());
            core.setOutput('trigger_source', triggerSource);
            core.setOutput('trigger_parsed', 'true');

      - name: Prepare task execution environment
        id: prepare-task
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const path = require('path');
            const executeSequentialTask = require(path.join(process.cwd(), 'scripts', 'execute-sequential-task.js'));
            
            try {
              // Use parameters parsed from the trigger (either comment or workflow_dispatch)
              const taskIndex = parseInt('${{ steps.parse-trigger.outputs.task_index }}');
              const previousBranch = '${{ steps.parse-trigger.outputs.previous_branch }}';
              const parentIssue = parseInt('${{ steps.parse-trigger.outputs.parent_issue }}');
              const triggerSource = '${{ steps.parse-trigger.outputs.trigger_source }}';
              
              console.log('üîç Sequential Task Execution Parameters:');
              console.log(`   - Event name: ${context.eventName}`);
              console.log(`   - Trigger source: ${triggerSource}`);
              console.log(`   - Task index: ${taskIndex}`);
              console.log(`   - Previous branch: ${previousBranch}`);
              console.log(`   - Parent issue: ${parentIssue}`);
              
              // Create client_payload equivalent for the executeSequentialTask function
              context.payload.client_payload = {
                task_index: taskIndex,
                previous_branch: previousBranch,
                parent_issue: parentIssue,
                trigger_source: triggerSource
              };
              
              const taskContext = await executeSequentialTask({ github, context, core });
              
              console.log('üìã Task execution context prepared:');
              console.log(`   - Task: ${taskContext.taskData.title}`);
              console.log(`   - Index: ${taskContext.taskIndex + 1}/${taskContext.totalTasks}`);
              console.log(`   - Branch: ${taskContext.currentBranch}`);
              console.log(`   - Base: ${taskContext.previousBranch}`);
              
              // Set outputs for next steps
              core.setOutput('task_title', taskContext.taskData.title);
              core.setOutput('task_index', taskContext.taskIndex.toString());
              core.setOutput('task_number', (taskContext.taskIndex + 1).toString());
              core.setOutput('total_tasks', taskContext.totalTasks.toString());
              core.setOutput('current_branch', taskContext.currentBranch);
              core.setOutput('previous_branch', taskContext.previousBranch);
              core.setOutput('task_prepared', 'true');
              
            } catch (error) {
              console.log('‚ùå Task preparation failed:', error.message);
              console.log('üîç Full error details:', error);
              core.setFailed(`Task preparation failed: ${error.message}`);
            }

      - name: Verify branch availability
        if: steps.prepare-task.outputs.task_prepared == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const currentBranch = '${{ steps.prepare-task.outputs.current_branch }}';
            
            if (!currentBranch) {
              throw new Error('Current branch not specified - task preparation may have failed');
            }
            
            // Wait a moment for branch to be available on remote
            console.log(`üîç Verifying branch ${currentBranch} is available on remote...`);
            
            let retries = 0;
            const maxRetries = 15;
            
            while (retries < maxRetries) {
              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: currentBranch
                });
                
                console.log(`‚úÖ Branch ${currentBranch} confirmed available on remote`);
                break;
                
              } catch (error) {
                retries++;
                console.log(`‚è≥ Branch not yet available (attempt ${retries}/${maxRetries}), waiting 3s...`);
                
                if (retries >= maxRetries) {
                  console.log(`‚ùå Branch availability check failed after ${maxRetries} attempts`);
                  console.log(`üîç Error details: ${error.message}`);
                  console.log(`üîç Repository: ${context.repo.owner}/${context.repo.repo}`);
                  console.log(`üîç Expected branch: ${currentBranch}`);
                  
                  throw new Error(`Branch ${currentBranch} not available after ${maxRetries * 3} seconds. This may indicate:
                    - Git push operation failed in task preparation
                    - Network connectivity issues
                    - GitHub API rate limiting
                    - Repository permissions issues`);
                }
                
                // Wait 3 seconds before retry
                await new Promise(resolve => setTimeout(resolve, 3000));
              }
            }

      - name: Implement task with Claude Code Action
        id: claude-implementation
        if: steps.prepare-task.outputs.task_prepared == 'true'
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          custom_instructions: |
            **TASK**: ${{ steps.prepare-task.outputs.task_title }}
            
            **IMPLEMENTATION REQUIRED**: Create actual working code, files, and implementations - not task descriptions or documentation.
            
            **SPECIFIC INSTRUCTIONS**:
            - Examine the existing codebase to understand the project structure
            - Implement the specific functionality described in the task title
            - Create or modify all necessary files
            - Follow existing code patterns and conventions
            - Ensure all code is functional and production-ready
            
            **CONTEXT**: This is task ${{ steps.prepare-task.outputs.task_number }} of ${{ steps.prepare-task.outputs.total_tasks }} in a sequential implementation. Build upon any existing changes from previous tasks if applicable.
          timeout_minutes: 30
          allowed_tools: "Read,Write,Edit,MultiEdit,Glob,Grep,Bash(git *),Bash(npm *),Bash(yarn *),Bash(node *),Bash(python *),Bash(pip *)"
          disallowed_tools: "Bash(rm *),Bash(sudo *),Bash(curl *),Bash(wget *),Bash(dd *)"

      - name: Verify Claude Code Action execution
        if: always() && steps.prepare-task.outputs.task_prepared == 'true'
        run: |
          echo "üîç Checking Claude Code Action execution status..."
          
          if [ "${{ steps.claude-implementation.outcome }}" = "failure" ]; then
            echo "‚ùå Claude Code Action failed to execute"
            echo "This could be due to:"
            echo "  - Authentication token issues"
            echo "  - Network connectivity problems"
            echo "  - Claude Code service unavailability"
            echo "  - Tool access restrictions"
            echo "  - Timeout exceeded"
            echo ""
            echo "üîç Next steps:"
            echo "  1. Check workflow logs for specific error messages"
            echo "  2. Verify CLAUDE_CODE_OAUTH_TOKEN is valid"
            echo "  3. Ensure allowed_tools includes necessary operations"
            echo "  4. Consider increasing timeout_minutes if needed"
            exit 1
          elif [ "${{ steps.claude-implementation.outcome }}" = "cancelled" ]; then
            echo "‚ö†Ô∏è Claude Code Action was cancelled"
            exit 1
          elif [ "${{ steps.claude-implementation.outcome }}" = "success" ]; then
            echo "‚úÖ Claude Code Action completed successfully"
          else
            echo "‚ö†Ô∏è Claude Code Action completed with unknown status: ${{ steps.claude-implementation.outcome }}"
          fi

      - name: Handle sequential task completion
        if: steps.prepare-task.outputs.task_prepared == 'true' && steps.claude-implementation.outcome == 'success'
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const path = require('path');
            const fs = require('fs');
            
            try {
              console.log('üìã Handling sequential task completion...');
              
              // Get task context from preparation step outputs
              const taskIndex = parseInt('${{ steps.prepare-task.outputs.task_index }}');
              const totalTasks = parseInt('${{ steps.prepare-task.outputs.total_tasks }}');
              const taskTitle = '${{ steps.prepare-task.outputs.task_title }}';
              const currentBranch = '${{ steps.prepare-task.outputs.current_branch }}';
              const previousBranch = '${{ steps.prepare-task.outputs.previous_branch }}';
              const parentIssue = parseInt('${{ steps.parse-trigger.outputs.parent_issue }}');
              
              console.log(`üìã Processing completion for Task ${taskIndex + 1}: ${taskTitle}`);
              
              // Create complete task context for completion handler
              const taskContext = {
                taskIndex: taskIndex,
                totalTasks: totalTasks,
                taskData: { title: taskTitle, body: `Task ${taskIndex + 1} implementation` },
                currentBranch: currentBranch,
                previousBranch: previousBranch,
                parentIssue: parentIssue,
                previousTasks: [] // This will be populated by the handler from state
              };
              
              console.log('üîß Importing task completion handler...');
              
              // Import the completion handler module directly
              const taskModule = require(path.join(process.cwd(), 'scripts', 'execute-sequential-task.js'));
              
              // Call the completion handler function
              console.log('üöÄ Calling handleTaskCompletion...');
              const result = await taskModule.handleTaskCompletion({ 
                github, 
                context, 
                core, 
                taskContext 
              });
              
              console.log('‚úÖ Task completion handler executed successfully');
              console.log(`üìã Result: ${JSON.stringify(result)}`);
              
              if (result.status === 'completed') {
                console.log(`‚úÖ Task ${taskContext.taskIndex + 1} completed successfully`);
                console.log(`üìù Created PR #${result.prNumber}`);
                console.log(`üöÄ Next task will be triggered automatically if applicable`);
                
                core.setOutput('pr_number', result.prNumber);
                core.setOutput('task_status', 'completed');
                
              } else if (result.status === 'no-changes') {
                console.log(`‚ö†Ô∏è Task ${taskContext.taskIndex + 1} completed with no changes needed`);
                console.log(`üöÄ Next task will be triggered automatically`);
                core.setOutput('task_status', 'no-changes');
                
              } else if (result.status === 'all_completed') {
                console.log('üéâ All sequential tasks have been completed!');
                core.setOutput('task_status', 'all_completed');
                core.setOutput('total_tasks_completed', result.tasksCompleted);
              }
              
            } catch (error) {
              console.log('‚ùå Sequential task completion handling failed:', error.message);
              console.log('üîç Full error details:', error);
              console.log('üîç Stack trace:', error.stack);
              
              // Post error comment to parent issue for debugging
              try {
                const parentIssue = parseInt('${{ steps.parse-trigger.outputs.parent_issue }}');
                if (parentIssue) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentIssue,
                    body: `## ‚ùå Task Completion Error
              
              **Task**: ${{ steps.prepare-task.outputs.task_title }}
              **Error**: ${error.message}
              
              The task implementation completed but post-processing failed. Please check the workflow logs for details.
              
              *This error occurred during sequential task completion handling.*`
                  });
                }
              } catch (commentError) {
                console.log('‚ö†Ô∏è Could not post error comment:', commentError.message);
              }
              
              core.setFailed(`Task completion failed: ${error.message}`);
            }

