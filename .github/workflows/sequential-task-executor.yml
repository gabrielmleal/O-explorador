name: Sequential Task Executor

on:
  issue_comment:
    types: [created]
  workflow_dispatch:
    inputs:
      task_index:
        description: 'Task index to execute (0-based)'
        required: true
        default: '0'
        type: string
      previous_branch:
        description: 'Previous branch to base from'
        required: false
        default: 'main'
        type: string
      parent_issue:
        description: 'Parent issue number'
        required: true
        type: string

jobs:
  execute-task:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' || 
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '[SEQUENTIAL-TASK-TRIGGER]'))
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}

      - name: Parse sequential task trigger
        id: parse-trigger
        uses: actions/github-script@v7
        with:
          script: |
            let taskIndex, previousBranch, parentIssue, triggerSource;
            
            if (context.eventName === 'workflow_dispatch') {
              // For manual workflow dispatch, use inputs
              taskIndex = parseInt(context.payload.inputs.task_index || '0');
              previousBranch = context.payload.inputs.previous_branch || 'main';
              parentIssue = parseInt(context.payload.inputs.parent_issue);
              triggerSource = 'manual_workflow_dispatch';
              
              console.log('üñ±Ô∏è Triggered by manual workflow_dispatch');
              console.log(`   - Task index: ${taskIndex}`);
              console.log(`   - Previous branch: ${previousBranch}`);
              console.log(`   - Parent issue: ${parentIssue}`);
              
            } else if (context.eventName === 'issue_comment') {
              // Parse the sequential task trigger comment
              const commentBody = context.payload.comment.body;
              console.log('üí¨ Triggered by issue comment');
              console.log(`   - Comment: ${commentBody}`);
              
              // Extract parameters from comment format: [SEQUENTIAL-TASK-TRIGGER] task_index=1 previous_branch=sequential/task-1 parent_issue=123
              const triggerMatch = commentBody.match(/\[SEQUENTIAL-TASK-TRIGGER\]\s+(.+)/);
              if (!triggerMatch) {
                throw new Error('Invalid sequential task trigger comment format');
              }
              
              const paramString = triggerMatch[1];
              console.log(`   - Parameters: ${paramString}`);
              
              // Parse individual parameters
              const taskIndexMatch = paramString.match(/task_index=(\d+)/);
              const previousBranchMatch = paramString.match(/previous_branch=([^\s]+)/);
              const parentIssueMatch = paramString.match(/parent_issue=(\d+)/);
              
              if (!taskIndexMatch || !previousBranchMatch || !parentIssueMatch) {
                throw new Error('Missing required parameters in sequential task trigger comment');
              }
              
              taskIndex = parseInt(taskIndexMatch[1]);
              previousBranch = previousBranchMatch[1];
              parentIssue = parseInt(parentIssueMatch[1]);
              triggerSource = 'sequential_task_comment';
              
              console.log('‚úÖ Parsed trigger parameters:');
              console.log(`   - Task index: ${taskIndex}`);
              console.log(`   - Previous branch: ${previousBranch}`);
              console.log(`   - Parent issue: ${parentIssue}`);
              
              // Verify this comment is on the correct issue
              if (context.payload.issue.number !== parentIssue) {
                throw new Error(`Comment posted on wrong issue. Expected: ${parentIssue}, Actual: ${context.payload.issue.number}`);
              }
            } else {
              throw new Error(`Unsupported event type: ${context.eventName}`);
            }
            
            // Set outputs for next steps
            core.setOutput('task_index', taskIndex.toString());
            core.setOutput('previous_branch', previousBranch);
            core.setOutput('parent_issue', parentIssue.toString());
            core.setOutput('trigger_source', triggerSource);
            core.setOutput('trigger_parsed', 'true');

      - name: Prepare task execution environment
        id: prepare-task
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const path = require('path');
            const executeSequentialTask = require(path.join(process.cwd(), 'scripts', 'execute-sequential-task.js'));
            
            try {
              // Use parameters parsed from the trigger (either comment or workflow_dispatch)
              const taskIndex = parseInt('${{ steps.parse-trigger.outputs.task_index }}');
              const previousBranch = '${{ steps.parse-trigger.outputs.previous_branch }}';
              const parentIssue = parseInt('${{ steps.parse-trigger.outputs.parent_issue }}');
              const triggerSource = '${{ steps.parse-trigger.outputs.trigger_source }}';
              
              console.log('üîç Sequential Task Execution Parameters:');
              console.log(`   - Event name: ${context.eventName}`);
              console.log(`   - Trigger source: ${triggerSource}`);
              console.log(`   - Task index: ${taskIndex}`);
              console.log(`   - Previous branch: ${previousBranch}`);
              console.log(`   - Parent issue: ${parentIssue}`);
              
              // Create client_payload equivalent for the executeSequentialTask function
              context.payload.client_payload = {
                task_index: taskIndex,
                previous_branch: previousBranch,
                parent_issue: parentIssue,
                trigger_source: triggerSource
              };
              
              const taskContext = await executeSequentialTask({ github, context, core });
              
              console.log('üìã Task execution context prepared:');
              console.log(`   - Task: ${taskContext.taskData.title}`);
              console.log(`   - Index: ${taskContext.taskIndex + 1}/${taskContext.totalTasks}`);
              console.log(`   - Branch: ${taskContext.currentBranch}`);
              console.log(`   - Base: ${taskContext.previousBranch}`);
              
              // Set outputs for next steps
              core.setOutput('task_title', taskContext.taskData.title);
              core.setOutput('task_index', taskContext.taskIndex.toString());
              core.setOutput('task_number', (taskContext.taskIndex + 1).toString());
              core.setOutput('total_tasks', taskContext.totalTasks.toString());
              core.setOutput('current_branch', taskContext.currentBranch);
              core.setOutput('previous_branch', taskContext.previousBranch);
              core.setOutput('task_prepared', 'true');
              
            } catch (error) {
              console.log('‚ùå Task preparation failed:', error.message);
              console.log('üîç Full error details:', error);
              core.setFailed(`Task preparation failed: ${error.message}`);
            }

      - name: Verify branch availability
        if: steps.prepare-task.outputs.task_prepared == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const currentBranch = '${{ steps.prepare-task.outputs.current_branch }}';
            
            // Wait a moment for branch to be available on remote
            console.log(`üîç Verifying branch ${currentBranch} is available on remote...`);
            
            let retries = 0;
            const maxRetries = 10;
            
            while (retries < maxRetries) {
              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: currentBranch
                });
                
                console.log(`‚úÖ Branch ${currentBranch} confirmed available on remote`);
                break;
                
              } catch (error) {
                retries++;
                console.log(`‚è≥ Branch not yet available (attempt ${retries}/${maxRetries}), waiting 2s...`);
                
                if (retries >= maxRetries) {
                  throw new Error(`Branch ${currentBranch} not available after ${maxRetries} attempts: ${error.message}`);
                }
                
                // Wait 2 seconds before retry
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            }

      - name: Implement task with Claude Code Action
        if: steps.prepare-task.outputs.task_prepared == 'true'
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          custom_instructions: |
            You are implementing Task ${{ steps.prepare-task.outputs.task_number }} of ${{ steps.prepare-task.outputs.total_tasks }} in a SEQUENTIAL task execution system.

            **CRITICAL CONTEXT**: This task builds on previous tasks changes. You are currently working on branch `${{ steps.prepare-task.outputs.current_branch }}` which was created from `${{ steps.prepare-task.outputs.previous_branch }}`.

            **TASK TO IMPLEMENT**: ${{ steps.prepare-task.outputs.task_title }}

            **SEQUENTIAL EXECUTION CONTEXT**:
            - Task Index: ${{ steps.prepare-task.outputs.task_number }}/${{ steps.prepare-task.outputs.total_tasks }}
            - Current Branch: `${{ steps.prepare-task.outputs.current_branch }}`
            - Base Branch: `${{ steps.prepare-task.outputs.previous_branch }}`
            - Task Context: Available in `current-task-context.json`

            **INSTRUCTIONS**:
            1. Read `CLAUDE.md` for project guidelines and understand the sequential task execution system
            2. **CRITICAL**: Read `current-task-context.json` which contains:
               - `taskData`: Full task details (title, description, requirements)
               - `sequentialContext`: The original project context and requirements
               - `previousTasks`: All completed tasks and their implementations
               - `taskIndex`/`totalTasks`: Your position in the sequence
               - `previousBranch`: The branch containing previous tasks' changes
            3. Examine existing code to understand previous tasks implementations
            4. Implement this specific task building on existing changes from previous tasks
            5. Follow project conventions and best practices
            6. Create/modify all necessary files for this task
            7. Ensure code is production-ready with proper error handling
            8. Write tests if the project has testing infrastructure

            **IMPORTANT SEQUENTIAL CONSIDERATIONS**:
            - You are working with cumulative changes from previous tasks
            - Use the `sequentialContext` from the context file to understand the overall goal
            - Review `previousTasks` to understand what has already been implemented
            - Focus only on implementing this specific task (`taskData.title` and `taskData.body`)
            - Build upon and integrate with existing code from previous tasks
            - Do not redo work from previous tasks unless necessary for integration
            - Your changes will be part of a stacked PR system

            **YOUR GOAL**: Implement working code for this task, not just task descriptions. Create actual files, functions, and implementations that fulfill the task requirements. Use all the context information to understand dependencies and build upon previous work.
          timeout_minutes: 30

      - name: Handle sequential task completion
        if: always() && steps.prepare-task.outputs.task_prepared == 'true'
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const path = require('path');
            const fs = require('fs');
            
            try {
              console.log('üìã Handling sequential task completion...');
              
              // Check if current-task-context.json exists (should exist from task preparation)
              if (!fs.existsSync('current-task-context.json')) {
                console.log('‚ùå Current task context file not found');
                core.setFailed('Task context file missing - cannot handle completion');
                return;
              }
              
              const taskContext = JSON.parse(fs.readFileSync('current-task-context.json', 'utf8'));
              console.log(`üìã Processing completion for Task ${taskContext.taskIndex + 1}: ${taskContext.taskData.title}`);
              
              // Import the task completion handler
              const executeSequentialTask = require(path.join(process.cwd(), 'scripts', 'execute-sequential-task.js'));
              
              // Handle task completion (PR creation and next task triggering)
              const result = await executeSequentialTask.handleTaskCompletion({ 
                github, 
                context, 
                core, 
                taskContext 
              });
              
              if (result.status === 'completed') {
                console.log(`‚úÖ Task ${taskContext.taskIndex + 1} completed successfully`);
                console.log(`üìù Created PR #${result.prNumber}`);
                console.log(`üöÄ Next task will be triggered automatically if applicable`);
                
                core.setOutput('pr_number', result.prNumber);
                core.setOutput('task_status', 'completed');
                
              } else if (result.status === 'no-changes') {
                console.log(`‚ö†Ô∏è Task ${taskContext.taskIndex + 1} completed with no changes needed`);
                console.log(`üöÄ Next task will be triggered automatically`);
                core.setOutput('task_status', 'no-changes');
                
              } else if (result.status === 'all_completed') {
                console.log('üéâ All sequential tasks have been completed!');
                core.setOutput('task_status', 'all_completed');
                core.setOutput('total_tasks_completed', result.tasksCompleted);
              }
              
            } catch (error) {
              console.log('‚ùå Sequential task completion handling failed:', error.message);
              console.log('üîç Full error:', error);
              core.setFailed(`Task completion failed: ${error.message}`);
            }

      - name: Upload task artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sequential-task-${{ steps.prepare-task.outputs.task_number || 'unknown' }}-artifacts
          path: |
            current-task-context.json
          retention-days: 30