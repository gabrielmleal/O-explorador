name: Sequential Task System

on:
  workflow_dispatch:
    inputs:
      context:
        description: 'Project context or requirements to decompose into sequential tasks'
        required: true
        type: string
      max_tasks:
        description: 'Maximum number of tasks to create'
        required: false
        default: '10'
        type: string
      recovery_action:
        description: 'Recovery action (status/recover/reset)'
        required: false
        type: choice
        options:
          - 'none'
          - 'status'
          - 'recover'
          - 'reset'
        default: 'none'
      resume_from_task:
        description: 'Task index to resume from (0-based, for recover action)'
        required: false
        type: string
      confirm_reset:
        description: 'Type "RESET" to confirm complete reset'
        required: false
        type: string
  issues:
    types: [opened, edited]
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]

jobs:
  determine-action:
    runs-on: ubuntu-latest
    outputs:
      action_type: ${{ steps.determine.outputs.action_type }}
      parent_issue: ${{ steps.determine.outputs.parent_issue }}
      task_index: ${{ steps.determine.outputs.task_index }}
      previous_branch: ${{ steps.determine.outputs.previous_branch }}
    steps:
      - name: Determine workflow action
        id: determine
        uses: actions/github-script@v7
        with:
          script: |
            const eventName = context.eventName;
            
            // Recovery action via workflow_dispatch
            if (eventName === 'workflow_dispatch' && context.payload.inputs.recovery_action !== 'none') {
              core.setOutput('action_type', 'recovery');
              return;
            }
            
            // Context decomposition via workflow_dispatch or sequential-context issue
            if (eventName === 'workflow_dispatch' || 
                (eventName === 'issues' && 
                 context.payload.issue.labels.some(l => l.name === 'sequential-context') && 
                 context.payload.issue.body.includes('@claude'))) {
              core.setOutput('action_type', 'setup');
              core.setOutput('parent_issue', context.payload.issue?.number || 'manual');
              return;
            }
            
            // Sequential task execution trigger
            if (eventName === 'issue_comment' && 
                context.payload.comment.body.includes('[SEQUENTIAL-TASK-TRIGGER]') &&
                context.payload.comment.body.includes('@claude')) {
              
              const commentBody = context.payload.comment.body;
              const triggerMatch = commentBody.match(/\[SEQUENTIAL-TASK-TRIGGER\]\s+(.+)/);
              
              if (triggerMatch) {
                const paramString = triggerMatch[1];
                const taskIndexMatch = paramString.match(/task_index=(\d+)/);
                const previousBranchMatch = paramString.match(/previous_branch=([^\s]+)/);
                const parentIssueMatch = paramString.match(/parent_issue=(\d+)/);
                
                if (taskIndexMatch && previousBranchMatch && parentIssueMatch) {
                  core.setOutput('action_type', 'execute');
                  core.setOutput('task_index', taskIndexMatch[1]);
                  core.setOutput('previous_branch', previousBranchMatch[1]);
                  core.setOutput('parent_issue', parentIssueMatch[1]);
                  return;
                }
              }
            }
            
            // Standalone Claude implementation
            if ((eventName === 'issue_comment' && 
                 context.payload.comment.body.includes('@claude') && 
                 !context.payload.comment.body.includes('[SEQUENTIAL-TASK-TRIGGER]')) ||
                (eventName === 'pull_request_review_comment' && 
                 context.payload.comment.body.includes('@claude')) ||
                (eventName === 'issues' && 
                 context.payload.issue.body.includes('@claude') && 
                 !context.payload.issue.labels.some(l => l.name === 'sequential-context'))) {
              core.setOutput('action_type', 'standalone');
              return;
            }
            
            core.setOutput('action_type', 'skip');

  setup-sequential-tasks:
    needs: determine-action
    if: needs.determine-action.outputs.action_type == 'setup'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      id-token: write
      actions: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}

      - name: Decompose context with Claude Code
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          timeout_minutes: 20
          custom_instructions: |
            Create a file named `tasks.json` that breaks down the project requirement into 3-5 sequential implementation tasks.

            Project requirements:
            ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.context || github.event.issue.body }}

            Create tasks.json with this exact structure:
            ```json
            {
              "tasks": [
                {
                  "title": "Clear task title describing what to implement",
                  "body": "Detailed description of what to build/create/implement"
                }
              ]
            }
            ```

            **REQUIREMENTS**:
            - 3-5 tasks maximum that build sequentially
            - Focus on actual implementation, not planning
            - ONLY create the tasks.json file - DO NOT make any other changes
          allowed_tools: "Write,Read"
          disallowed_tools: "Bash,Edit,MultiEdit,Grep,Glob"

      - name: Setup sequential execution
        uses: actions/github-script@v7
        env:
          PARENT_ISSUE_NUMBER: ${{ needs.determine-action.outputs.parent_issue != 'manual' && needs.determine-action.outputs.parent_issue || github.event.issue.number }}
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const setupSequentialTasks = require('./scripts/sequential/setup.js');
            
            try {
              const result = await setupSequentialTasks({ github, context, core });
              console.log(`‚úÖ Sequential execution setup complete: ${result.tasksCount} tasks prepared`);
              core.setOutput('tasks_count', result.tasksCount);
            } catch (error) {
              console.log('‚ùå Sequential setup failed:', error.message);
              core.setFailed(`Sequential setup failed: ${error.message}`);
            }

  execute-sequential-task:
    needs: determine-action
    if: needs.determine-action.outputs.action_type == 'execute'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}

      - name: Prepare task execution
        id: prepare-task
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const { executeSequentialTask } = require('./scripts/sequential/execute.js');
            
            try {
              context.payload.client_payload = {
                task_index: parseInt('${{ needs.determine-action.outputs.task_index }}'),
                previous_branch: '${{ needs.determine-action.outputs.previous_branch }}',
                parent_issue: parseInt('${{ needs.determine-action.outputs.parent_issue }}')
              };
              
              const taskContext = await executeSequentialTask({ github, context, core });
              
              core.setOutput('task_title', taskContext.taskData.title);
              core.setOutput('task_number', (taskContext.taskIndex + 1).toString());
              core.setOutput('total_tasks', taskContext.totalTasks.toString());
              core.setOutput('current_branch', taskContext.currentBranch);
              core.setOutput('state_comment_id', taskContext.stateCommentId);
              core.setOutput('task_prepared', 'true');
              
            } catch (error) {
              console.log('‚ùå Task preparation failed:', error.message);
              core.setFailed(`Task preparation failed: ${error.message}`);
            }

      - name: Implement task with Claude Code Action
        if: steps.prepare-task.outputs.task_prepared == 'true'
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          base_branch: ${{ steps.prepare-task.outputs.current_branch }}
          timeout_minutes: 30
          custom_instructions: |
            **üéØ SEQUENTIAL TASK IMPLEMENTATION**
            
            **CRITICAL: READ CONTEXT FILE FIRST**
            - **MUST READ**: `current-task-context.json` contains comprehensive context about previous implementations
            
            **CURRENT TASK**: ${{ steps.prepare-task.outputs.task_title }}
            **Task Number**: ${{ steps.prepare-task.outputs.task_number }} of ${{ steps.prepare-task.outputs.total_tasks }}
            
            **üö® IMPLEMENTATION SCOPE**:
            - **ONLY IMPLEMENT** the functionality described in your current task title
            - **BUILD UPON** existing code from previous tasks, don't replace it
            - Your working directory contains accumulated changes from ALL previous sequential tasks
            
            **üìã IMPLEMENTATION STEPS**:
            1. **READ** `current-task-context.json` for full context
            2. **ANALYZE** existing code and previous implementations
            3. **IMPLEMENT** only your current task, building incrementally
            4. Create actual working code, not documentation
          allowed_tools: "Read,Write,Edit,MultiEdit,Glob,Grep,Bash(git *),Bash(npm *),Bash(yarn *),Bash(node *),Bash(python *),Bash(pip *)"
          disallowed_tools: "Bash(rm *),Bash(sudo *),Bash(curl *),Bash(wget *),Bash(dd *)"

      - name: Handle task completion
        if: steps.prepare-task.outputs.task_prepared == 'true'
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const { handleTaskCompletion } = require('./scripts/sequential/execute.js');
            
            try {
              const taskContext = {
                taskIndex: parseInt('${{ steps.prepare-task.outputs.task_number }}') - 1,
                currentBranch: '${{ steps.prepare-task.outputs.current_branch }}',
                previousBranch: '${{ needs.determine-action.outputs.previous_branch }}',
                parentIssue: parseInt('${{ needs.determine-action.outputs.parent_issue }}'),
                stateCommentId: '${{ steps.prepare-task.outputs.state_comment_id }}'
              };
              
              const result = await handleTaskCompletion({ github, context, core, taskContext });
              
              if (result.status === 'completed') {
                console.log(`‚úÖ Task completed successfully with PR #${result.prNumber}`);
                core.setOutput('pr_number', result.prNumber);
              } else if (result.status === 'all_completed') {
                console.log('üéâ All sequential tasks completed!');
              }
              
            } catch (error) {
              console.log('‚ùå Task completion failed:', error.message);
              core.setFailed(`Task completion failed: ${error.message}`);
            }

  standalone-claude-task:
    needs: determine-action
    if: needs.determine-action.outputs.action_type == 'standalone'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
      actions: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}

      - name: Run Claude Code Action
        uses: anthropics/claude-code-action@beta
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          timeout_minutes: 20
          custom_instructions: |
            You are Claude Code helping with a development task.

            **CONTEXT**: This is a standalone task (not part of sequential execution).

            **INSTRUCTIONS**:
            1. Read `CLAUDE.md` for project guidelines and best practices
            2. Understand the request from the user's comment or issue
            3. Examine the current codebase to understand the project structure
            4. Implement the requested changes following project conventions
            5. Ensure code is production-ready with proper error handling
            6. Write tests if the project has testing infrastructure
            7. Make sure your implementation is complete and functional

            **YOUR GOAL**: Implement working code that fulfills the user's request.

            The user mentioned @claude in their comment/issue. Please help them with their request by implementing the necessary code changes.
          allowed_tools: "Read,Write,Edit,MultiEdit,Glob,Grep,Bash(git *),Bash(npm *),Bash(yarn *),Bash(node *),Bash(python *),Bash(pip *)"
          disallowed_tools: "Bash(rm *),Bash(sudo *),Bash(curl *),Bash(wget *),Bash(dd *)"

  recovery-operations:
    needs: determine-action
    if: needs.determine-action.outputs.action_type == 'recovery'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      actions: write
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}

      - name: Perform recovery operation
        uses: actions/github-script@v7
        env:
          WORKFLOW_TRIGGER_TOKEN: ${{ secrets.WORKFLOW_TRIGGER_TOKEN }}
          RECOVERY_ACTION: ${{ github.event.inputs.recovery_action }}
          RESUME_FROM_TASK: ${{ github.event.inputs.resume_from_task }}
          CONFIRM_RESET: ${{ github.event.inputs.confirm_reset }}
        with:
          github-token: ${{ secrets.WORKFLOW_TRIGGER_TOKEN || github.token }}
          script: |
            const { getSequentialStatus, recoverSequentialExecution, resetSequentialExecution } = require('./scripts/sequential/recovery.js');
            
            const action = process.env.RECOVERY_ACTION;
            const resumeFromTask = process.env.RESUME_FROM_TASK;
            const confirmReset = process.env.CONFIRM_RESET;
            
            try {
              let result;
              
              switch (action) {
                case 'status':
                  result = await getSequentialStatus(github, context.repo.owner, context.repo.repo, context.payload.issue?.number);
                  console.log('=== SEQUENTIAL EXECUTION STATUS ===');
                  console.log(`Overall Status: ${result.overall_status || 'unknown'}`);
                  console.log(`Total Tasks: ${result.total_tasks || 0}`);
                  console.log(`Completed: ${result.completed_tasks || 0}`);
                  console.log(`Failed: ${result.failed_tasks || 0}`);
                  break;
                
                case 'recover':
                  const resumeTaskIndex = resumeFromTask ? parseInt(resumeFromTask, 10) : null;
                  result = await recoverSequentialExecution({
                    github,
                    context,
                    core,
                    resumeFromTaskIndex: resumeTaskIndex,
                    parentIssue: context.payload.issue?.number
                  });
                  console.log('‚úÖ Recovery operation completed');
                  break;
                
                case 'reset':
                  if (confirmReset !== 'RESET') {
                    throw new Error('Reset not confirmed. Please enter "RESET" in the confirm_reset field to proceed.');
                  }
                  result = await resetSequentialExecution({
                    github,
                    context,
                    parentIssue: context.payload.issue?.number,
                    confirmReset: true
                  });
                  console.log('‚úÖ Reset operation completed');
                  break;
                
                default:
                  throw new Error(`Unknown recovery action: ${action}`);
              }
              
              core.setOutput('recovery_result', JSON.stringify(result, null, 2));
              
            } catch (error) {
              console.log(`‚ùå Recovery action '${action}' failed:`, error.message);
              core.setFailed(`Recovery operation failed: ${error.message}`);
            }

      - name: Upload recovery artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sequential-recovery-${{ github.event.inputs.recovery_action }}-${{ github.run_number }}
          path: |
            .github/sequential-tasks-state*.json
            sequential-tasks-state-backup-*.json
          retention-days: 30