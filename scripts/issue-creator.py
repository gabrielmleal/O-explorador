#!/usr/bin/env python3
"""
GitHub Issue Creator Script
Creates GitHub issues from a task list generated by the task decomposer
"""

import argparse
import json
import os
import sys
import time
from typing import List, Dict, Any, Optional
from pathlib import Path

try:
    from github import Github, GithubException
except ImportError:
    print("Error: PyGithub not installed. Run: pip install PyGithub", file=sys.stderr)
    sys.exit(1)


class IssueCreator:
    """Creates GitHub issues from task definitions"""
    
    def __init__(self, github_token: str = None, repo_name: str = None):
        """
        Initialize the issue creator
        
        Args:
            github_token: GitHub personal access token
            repo_name: Repository name in format 'owner/repo'
        """
        self.token = github_token or os.environ.get('GITHUB_TOKEN')
        if not self.token:
            raise ValueError("GITHUB_TOKEN not found in environment variables")
        
        self.github = Github(self.token)
        self.repo = None
        
        if repo_name:
            try:
                self.repo = self.github.get_repo(repo_name)
            except GithubException as e:
                print(f"Error accessing repository {repo_name}: {e}", file=sys.stderr)
                raise
    
    def create_issues_from_file(
        self,
        tasks_file: str,
        parent_issue: Optional[int] = None,
        auto_implement: bool = True,
        dry_run: bool = False
    ) -> List[int]:
        """
        Create GitHub issues from a tasks JSON file
        
        Args:
            tasks_file: Path to the tasks JSON file
            parent_issue: Optional parent issue number to reference
            auto_implement: Whether to add the auto-implement label
            dry_run: If True, don't actually create issues
        
        Returns:
            List of created issue numbers
        """
        # Load tasks from file
        with open(tasks_file, 'r') as f:
            tasks_data = json.load(f)
        
        if not tasks_data.get("tasks"):
            print("No tasks found in file", file=sys.stderr)
            return []
        
        # Create issues for each task
        created_issues = []
        task_to_issue_map = {}
        
        # First pass: Create all issues
        for task in tasks_data["tasks"]:
            issue_number = self._create_issue_from_task(
                task,
                parent_issue=parent_issue,
                auto_implement=auto_implement,
                dry_run=dry_run,
                context_summary=tasks_data.get("context_summary", ""),
                total_tasks=len(tasks_data["tasks"])
            )
            
            if issue_number:
                created_issues.append(issue_number)
                task_to_issue_map[task["id"]] = issue_number
            
            # Rate limiting
            if not dry_run:
                time.sleep(1)  # Avoid hitting GitHub rate limits
        
        # Second pass: Update issues with dependency links
        if not dry_run and task_to_issue_map:
            for task in tasks_data["tasks"]:
                if task.get("dependencies"):
                    self._add_dependency_comment(
                        task_to_issue_map.get(task["id"]),
                        task["dependencies"],
                        task_to_issue_map
                    )
        
        # Save the mapping for reference
        if created_issues:
            with open("created_issues.json", "w") as f:
                json.dump(created_issues, f, indent=2)
            
            print(f"\nCreated {len(created_issues)} issues:", file=sys.stderr)
            for issue_num in created_issues:
                print(f"  - Issue #{issue_num}", file=sys.stderr)
        
        return created_issues
    
    def _create_issue_from_task(
        self,
        task: Dict[str, Any],
        parent_issue: Optional[int] = None,
        auto_implement: bool = True,
        dry_run: bool = False,
        context_summary: str = "",
        total_tasks: int = 1
    ) -> Optional[int]:
        """
        Create a single GitHub issue from a task definition
        
        Args:
            task: Task dictionary
            parent_issue: Optional parent issue number
            auto_implement: Whether to add auto-implement label
            dry_run: If True, don't actually create the issue
            context_summary: Summary of the overall context
            total_tasks: Total number of tasks being created
        
        Returns:
            Created issue number or None
        """
        # Build issue title
        title = self._format_issue_title(task)
        
        # Build issue body
        body = self._format_issue_body(
            task,
            parent_issue=parent_issue,
            context_summary=context_summary,
            total_tasks=total_tasks
        )
        
        # Determine labels
        labels = self._determine_labels(task, auto_implement)
        
        if dry_run:
            print(f"\n[DRY RUN] Would create issue:", file=sys.stderr)
            print(f"  Title: {title}", file=sys.stderr)
            print(f"  Labels: {labels}", file=sys.stderr)
            print(f"  Body preview: {body[:200]}...", file=sys.stderr)
            return None
        
        try:
            # Create the issue
            issue = self.repo.create_issue(
                title=title,
                body=body,
                labels=labels
            )
            
            print(f"Created issue #{issue.number}: {title}", file=sys.stderr)
            return issue.number
            
        except GithubException as e:
            print(f"Error creating issue for task {task.get('id', 'unknown')}: {e}", file=sys.stderr)
            return None
    
    def _format_issue_title(self, task: Dict[str, Any]) -> str:
        """Format the issue title from a task"""
        title = task.get("title", "Untitled Task")
        
        # Add complexity indicator if high complexity
        if task.get("complexity") == "high":
            title = f"[Complex] {title}"
        
        # Ensure title isn't too long (GitHub limit is 256)
        if len(title) > 200:
            title = title[:197] + "..."
        
        return title
    
    def _format_issue_body(
        self,
        task: Dict[str, Any],
        parent_issue: Optional[int] = None,
        context_summary: str = "",
        total_tasks: int = 1
    ) -> str:
        """Format the issue body from a task"""
        body_parts = []
        
        # Header with task metadata
        body_parts.append("## 🤖 Auto-Generated Task")
        body_parts.append("")
        
        # Parent issue reference
        if parent_issue:
            body_parts.append(f"**Parent Issue:** #{parent_issue}")
            body_parts.append("")
        
        # Task ID and position
        if task.get("id"):
            task_position = task.get("priority", "N/A")
            body_parts.append(f"**Task ID:** `{task['id']}` (Task {task_position} of {total_tasks})")
            body_parts.append("")
        
        # Complexity badge
        complexity = task.get("complexity", "unknown")
        complexity_emoji = {"low": "🟢", "medium": "🟡", "high": "🔴"}.get(complexity, "⚪")
        body_parts.append(f"**Complexity:** {complexity_emoji} {complexity.capitalize()}")
        body_parts.append("")
        
        # Estimated hours
        if task.get("estimated_hours"):
            body_parts.append(f"**Estimated Hours:** {task['estimated_hours']}")
            body_parts.append("")
        
        # Context summary if provided
        if context_summary:
            body_parts.append("### 📋 Context")
            body_parts.append(context_summary)
            body_parts.append("")
        
        # Main description
        body_parts.append("### 📝 Description")
        body_parts.append(task.get("description", "No description provided"))
        body_parts.append("")
        
        # Implementation notes
        if task.get("implementation_notes"):
            body_parts.append("### 💡 Implementation Notes")
            body_parts.append(task["implementation_notes"])
            body_parts.append("")
        
        # Success criteria
        if task.get("success_criteria"):
            body_parts.append("### ✅ Success Criteria")
            for criterion in task["success_criteria"]:
                body_parts.append(f"- [ ] {criterion}")
            body_parts.append("")
        
        # Affected files
        if task.get("affected_files"):
            body_parts.append("### 📁 Affected Files")
            for file_path in task["affected_files"]:
                body_parts.append(f"- `{file_path}`")
            body_parts.append("")
        
        # Dependencies
        if task.get("dependencies"):
            body_parts.append("### 🔗 Dependencies")
            body_parts.append("This task depends on:")
            for dep in task["dependencies"]:
                body_parts.append(f"- `{dep}` (will be linked after creation)")
            body_parts.append("")
        
        # Risks
        if task.get("risks"):
            body_parts.append("### ⚠️ Risks")
            for risk in task["risks"]:
                body_parts.append(f"- {risk}")
            body_parts.append("")
        
        # Testing considerations
        body_parts.append("### 🧪 Testing")
        body_parts.append("- [ ] Unit tests written")
        body_parts.append("- [ ] Integration tests updated")
        body_parts.append("- [ ] Manual testing completed")
        body_parts.append("")
        
        # Footer
        body_parts.append("---")
        body_parts.append("*This issue was automatically generated from a task decomposition.*")
        body_parts.append("*Claude will automatically create a PR for this issue.*")
        
        return "\n".join(body_parts)
    
    def _determine_labels(self, task: Dict[str, Any], auto_implement: bool) -> List[str]:
        """Determine which labels to apply to the issue"""
        labels = []
        
        # Always add auto-implement if requested
        if auto_implement:
            labels.append("auto-implement")
        
        # Add complexity label
        complexity = task.get("complexity", "medium")
        labels.append(f"complexity:{complexity}")
        
        # Add task type labels based on keywords
        description = (task.get("description", "") + " " + task.get("title", "")).lower()
        
        if any(word in description for word in ["bug", "fix", "error", "issue"]):
            labels.append("bug")
        elif any(word in description for word in ["feature", "implement", "add", "create"]):
            labels.append("enhancement")
        elif any(word in description for word in ["refactor", "optimize", "improve"]):
            labels.append("refactor")
        elif any(word in description for word in ["test", "testing", "spec"]):
            labels.append("testing")
        elif any(word in description for word in ["document", "docs", "readme"]):
            labels.append("documentation")
        
        # Add priority label if high priority
        if task.get("priority", 999) <= 3:
            labels.append("priority:high")
        
        # Add auto-generated label
        labels.append("auto-generated")
        
        return labels
    
    def _add_dependency_comment(
        self,
        issue_number: Optional[int],
        dependencies: List[str],
        task_to_issue_map: Dict[str, int]
    ):
        """Add a comment to an issue listing its dependencies"""
        if not issue_number:
            return
        
        try:
            issue = self.repo.get_issue(issue_number)
            
            # Build dependency links
            dep_links = []
            for dep_task_id in dependencies:
                dep_issue = task_to_issue_map.get(dep_task_id)
                if dep_issue:
                    dep_links.append(f"- #{dep_issue}")
            
            if dep_links:
                comment = "### 🔗 Task Dependencies\n\n"
                comment += "This task depends on the following issues:\n"
                comment += "\n".join(dep_links)
                comment += "\n\nPlease ensure these are completed first."
                
                issue.create_comment(comment)
                
        except GithubException as e:
            print(f"Error adding dependency comment to issue #{issue_number}: {e}", file=sys.stderr)


def main():
    """Main entry point for the script"""
    parser = argparse.ArgumentParser(description='Create GitHub issues from task list')
    parser.add_argument(
        '--tasks-file',
        required=True,
        help='Path to the tasks JSON file'
    )
    parser.add_argument(
        '--repo',
        required=True,
        help='Repository name (format: owner/repo)'
    )
    parser.add_argument(
        '--parent-issue',
        type=int,
        help='Parent issue number to reference'
    )
    parser.add_argument(
        '--auto-implement',
        type=lambda x: x.lower() == 'true',
        default=True,
        help='Add auto-implement label to trigger PR creation (default: true)'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Perform a dry run without creating issues'
    )
    parser.add_argument(
        '--github-token',
        help='GitHub personal access token (defaults to GITHUB_TOKEN env var)'
    )
    
    args = parser.parse_args()
    
    try:
        # Initialize issue creator
        creator = IssueCreator(
            github_token=args.github_token,
            repo_name=args.repo
        )
        
        # Create issues
        print(f"Creating issues from {args.tasks_file}...", file=sys.stderr)
        if args.dry_run:
            print("DRY RUN MODE - No issues will be created", file=sys.stderr)
        
        created_issues = creator.create_issues_from_file(
            tasks_file=args.tasks_file,
            parent_issue=args.parent_issue,
            auto_implement=args.auto_implement,
            dry_run=args.dry_run
        )
        
        if not args.dry_run:
            print(f"\nSuccessfully created {len(created_issues)} issues", file=sys.stderr)
        
        return 0
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())