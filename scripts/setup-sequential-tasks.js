const fs = require('fs');

// State management utilities for issue-based storage
const STATE_COMMENT_PREFIX = '<!-- SEQUENTIAL_TASKS_STATE:';
const STATE_COMMENT_SUFFIX = ':END_STATE -->';

// Helper function to create state comment body
function createStateCommentBody(state) {
  const stateJson = JSON.stringify(state, null, 2);
  return `${STATE_COMMENT_PREFIX}\n${stateJson}\n${STATE_COMMENT_SUFFIX}\n\n## ü§ñ Sequential Tasks State\n\nThis comment contains the execution state for sequential tasks. **Do not modify this comment manually.**\n\n- **Status**: ${state.status}\n- **Current Task**: ${state.current_task_index + 1}/${state.tasks.length}\n- **Started**: ${state.started_at}\n- **Updated**: ${state.updated_at}`;
}

// Helper function to find and parse state from issue comments
async function findStateComment(github, owner, repo, issueNumber) {
  try {
    const { data: comments } = await github.rest.issues.listComments({
      owner,
      repo,
      issue_number: issueNumber,
      per_page: 100
    });
    
    for (const comment of comments) {
      if (comment.body.includes(STATE_COMMENT_PREFIX)) {
        const startIndex = comment.body.indexOf(STATE_COMMENT_PREFIX) + STATE_COMMENT_PREFIX.length;
        const endIndex = comment.body.indexOf(STATE_COMMENT_SUFFIX);
        if (endIndex > startIndex) {
          const stateJson = comment.body.substring(startIndex, endIndex).trim();
          return {
            comment_id: comment.id,
            state: JSON.parse(stateJson)
          };
        }
      }
    }
    return null;
  } catch (error) {
    console.log('Error searching for state comment:', error.message);
    return null;
  }
}

module.exports = async ({ github, context }) => {
  const workflowToken = process.env.WORKFLOW_TRIGGER_TOKEN;
  
  // Check if tasks.json exists (generated by Claude Code)
  if (!fs.existsSync('tasks.json')) {
    console.log('‚ùå tasks.json not found - Claude Code may have failed to generate the file');
    
    const parentIssue = process.env.PARENT_ISSUE_NUMBER || context.payload.issue?.number;
    if (parentIssue) {
      try {
        await github.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: parseInt(parentIssue),
          body: '‚ùå **Sequential task decomposition failed** - Claude Code was unable to generate the tasks.json file. Please check the context input and try again.'
        });
      } catch (commentError) {
        console.log('Failed to create error comment:', commentError.message);
      }
    }
    
    throw new Error('tasks.json file was not created by Claude Code');
  }

  // Read and parse tasks with error handling
  let tasksData;
  try {
    const fileContent = fs.readFileSync('tasks.json', 'utf8');
    tasksData = JSON.parse(fileContent);
  } catch (error) {
    console.log('‚ùå Failed to parse tasks.json:', error.message);
    
    const parentIssue = process.env.PARENT_ISSUE_NUMBER || context.payload.issue?.number;
    if (parentIssue) {
      try {
        await github.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: parseInt(parentIssue),
          body: `‚ùå **Sequential task decomposition failed** - tasks.json file is invalid: ${error.message}`
        });
      } catch (commentError) {
        console.log('Failed to create error comment:', commentError.message);
      }
    }
    
    throw new Error('Invalid tasks.json file');
  }

  // Validate JSON structure
  if (!tasksData || typeof tasksData !== 'object') {
    throw new Error('tasks.json does not contain a valid object');
  }

  if (!Array.isArray(tasksData.tasks)) {
    throw new Error('tasks.json missing tasks array');
  }

  const tasks = tasksData.tasks;
  const parentIssue = process.env.PARENT_ISSUE_NUMBER || tasksData.parent_issue || context.payload.issue?.number;

  // Validate individual tasks
  for (let i = 0; i < tasks.length; i++) {
    const task = tasks[i];
    if (!task.title || typeof task.title !== 'string') {
      throw new Error(`Task ${i + 1} has invalid title`);
    }
    if (!task.body || typeof task.body !== 'string') {
      throw new Error(`Task ${i + 1} has invalid body`);
    }
  }

  if (tasks.length === 0) {
    console.log('‚ö†Ô∏è No tasks found to create');
    return { tasksCount: 0 };
  }

  console.log(`Setting up ${tasks.length} tasks for sequential execution...`);

  // Create sequential tasks state
  const sequentialState = {
    context: context.payload.inputs?.context || context.payload.issue?.body || 'No context provided',
    parent_issue: parentIssue ? parseInt(parentIssue) : null,
    tasks: tasks.map((task, index) => ({
      id: index + 1,
      title: task.title,
      body: task.body,
      status: 'pending',
      branch: `sequential/issue-${parentIssue || 'unknown'}/task-${index + 1}`,
      pr_number: null,
      created_at: new Date().toISOString(),
      completed_at: null,
      error_message: null
    })),
    current_task_index: 0,
    previous_branch: 'main',
    status: 'pending',
    started_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    workflow_run_id: context.runId
  };

  console.log(`‚úÖ Sequential tasks state created with ${tasks.length} tasks`);
  console.log(`üìù State will be stored in issue #${parentIssue} comments`);

  // Create state comment and progress tracking on parent issue
  if (parentIssue) {
    try {
      // First create the progress tracking comment
      await github.rest.issues.createComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: parseInt(parentIssue),
        body: `## üöÄ Sequential Task Execution Started

Created ${tasks.length} tasks for sequential implementation:

${tasks.map((task, i) => `- [ ] **Task ${i + 1}**: ${task.title}`).join('\n')}

${'---'}

**Execution Strategy:**
- ‚úÖ Tasks will execute **one at a time** in order
- üîó Each task builds on the changes from the previous task
- üìù Each task will create a PR that stacks on the previous task's branch
- ‚ö° Next task automatically triggers when current task completes

*Sequential execution is now in progress...*`
      });

      // Then create the state comment
      const stateCommentBody = createStateCommentBody(sequentialState);
      await github.rest.issues.createComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: parseInt(parentIssue),
        body: stateCommentBody
      });

      console.log('‚úÖ Sequential tasks state stored in issue comments');
    } catch (error) {
      console.log('Failed to create state comment on parent issue:', error.message);
      throw new Error('Could not store sequential state in issue comments');
    }
  } else {
    throw new Error('Parent issue required for state storage');
  }

  // Trigger first task execution using issue comment
  try {
    // Create a sequential task trigger comment
    const triggerComment = `[SEQUENTIAL-TASK-TRIGGER] task_index=0 previous_branch=main parent_issue=${parentIssue}

üöÄ **Sequential Task Execution Started**

@claude Starting execution of Task 1 of ${tasksData.tasks.length}. This comment was automatically posted by the Sequential Task Setup system to trigger the first task.

**Task 1**: ${tasksData.tasks[0]?.title || 'Task title not available'}

*This is an automated trigger comment - the sequential workflow will now execute the first task.*`;

    await github.rest.issues.createComment({
      owner: context.repo.owner,
      repo: context.repo.repo,
      issue_number: parentIssue,
      body: triggerComment
    });
    
    console.log('üöÄ Successfully triggered first task execution via comment');
  } catch (error) {
    console.log('‚ùå Failed to trigger first task execution:', error.message);
    throw new Error('Could not start sequential task execution');
  }

  return {
    tasksCount: tasks.length,
    stateStorage: 'issue-comments',
    parentIssue: parentIssue,
    firstTaskTriggered: true
  };
};

// Export utility functions for use by other scripts
module.exports.createStateCommentBody = createStateCommentBody;
module.exports.findStateComment = findStateComment;