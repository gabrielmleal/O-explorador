const fs = require('fs');
const path = require('path');

module.exports = async ({ github, context }) => {
  const workflowToken = process.env.WORKFLOW_TRIGGER_TOKEN;
  
  // Check if tasks.json exists (generated by Claude Code)
  if (!fs.existsSync('tasks.json')) {
    console.log('‚ùå tasks.json not found - Claude Code may have failed to generate the file');
    
    const parentIssue = process.env.PARENT_ISSUE_NUMBER || context.payload.issue?.number;
    if (parentIssue) {
      try {
        await github.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: parseInt(parentIssue),
          body: '‚ùå **Sequential task decomposition failed** - Claude Code was unable to generate the tasks.json file. Please check the context input and try again.'
        });
      } catch (commentError) {
        console.log('Failed to create error comment:', commentError.message);
      }
    }
    
    throw new Error('tasks.json file was not created by Claude Code');
  }

  // Read and parse tasks with error handling
  let tasksData;
  try {
    const fileContent = fs.readFileSync('tasks.json', 'utf8');
    tasksData = JSON.parse(fileContent);
  } catch (error) {
    console.log('‚ùå Failed to parse tasks.json:', error.message);
    
    const parentIssue = process.env.PARENT_ISSUE_NUMBER || context.payload.issue?.number;
    if (parentIssue) {
      try {
        await github.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: parseInt(parentIssue),
          body: `‚ùå **Sequential task decomposition failed** - tasks.json file is invalid: ${error.message}`
        });
      } catch (commentError) {
        console.log('Failed to create error comment:', commentError.message);
      }
    }
    
    throw new Error('Invalid tasks.json file');
  }

  // Validate JSON structure
  if (!tasksData || typeof tasksData !== 'object') {
    throw new Error('tasks.json does not contain a valid object');
  }

  if (!Array.isArray(tasksData.tasks)) {
    throw new Error('tasks.json missing tasks array');
  }

  const tasks = tasksData.tasks;
  const parentIssue = process.env.PARENT_ISSUE_NUMBER || tasksData.parent_issue || context.payload.issue?.number;

  // Validate individual tasks
  for (let i = 0; i < tasks.length; i++) {
    const task = tasks[i];
    if (!task.title || typeof task.title !== 'string') {
      throw new Error(`Task ${i + 1} has invalid title`);
    }
    if (!task.body || typeof task.body !== 'string') {
      throw new Error(`Task ${i + 1} has invalid body`);
    }
  }

  if (tasks.length === 0) {
    console.log('‚ö†Ô∏è No tasks found to create');
    return { tasksCount: 0 };
  }

  console.log(`Setting up ${tasks.length} tasks for sequential execution...`);

  // Create sequential tasks state
  const sequentialState = {
    context: context.payload.inputs?.context || context.payload.issue?.body || 'No context provided',
    parent_issue: parentIssue ? parseInt(parentIssue) : null,
    tasks: tasks.map((task, index) => ({
      id: index + 1,
      title: task.title,
      body: task.body,
      status: 'pending',
      branch: `sequential/task-${index + 1}`,
      pr_number: null,
      created_at: new Date().toISOString(),
      completed_at: null,
      error_message: null
    })),
    current_task_index: 0,
    previous_branch: 'main',
    status: 'pending',
    started_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    workflow_run_id: context.runId
  };

  // Ensure .github directory exists
  const githubDir = '.github';
  if (!fs.existsSync(githubDir)) {
    fs.mkdirSync(githubDir, { recursive: true });
  }

  // Write sequential tasks state file
  const stateFilePath = path.join(githubDir, 'sequential-tasks-state.json');
  fs.writeFileSync(stateFilePath, JSON.stringify(sequentialState, null, 2));

  console.log(`‚úÖ Sequential tasks state created with ${tasks.length} tasks`);
  console.log(`üìÅ State file: ${stateFilePath}`);

  // Create progress tracking comment on parent issue if exists
  if (parentIssue) {
    try {
      await github.rest.issues.createComment({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: parseInt(parentIssue),
        body: `## üöÄ Sequential Task Execution Started

Created ${tasks.length} tasks for sequential implementation:

${tasks.map((task, i) => `- [ ] **Task ${i + 1}**: ${task.title}`).join('\n')}

${'---'}

**Execution Strategy:**
- ‚úÖ Tasks will execute **one at a time** in order
- üîó Each task builds on the changes from the previous task
- üìù Each task will create a PR that stacks on the previous task's branch
- ‚ö° Next task automatically triggers when current task completes

*Sequential execution is now in progress...*`
      });
    } catch (error) {
      console.log('Failed to create progress comment on parent issue:', error.message);
    }
  }

  // Commit and push the state file to repository
  try {
    // Configure git
    const { execSync } = require('child_process');
    execSync('git config user.name "Claude Sequential Bot"');
    execSync('git config user.email "claude-sequential@anthropic.com"');
    
    // Add, commit and push state file
    execSync(`git add "${stateFilePath}"`);
    execSync(`git commit -m "Initialize sequential tasks state

- Created state file for ${tasks.length} sequential tasks
- Ready to begin task execution chain
- Parent issue: ${parentIssue ? `#${parentIssue}` : 'none'}

ü§ñ Generated with Claude Code Sequential Executor"`);
    
    execSync('git push origin HEAD');
    
    console.log('‚úÖ Sequential tasks state committed and pushed to repository');
  } catch (error) {
    console.log('‚ö†Ô∏è Warning: Failed to commit state file to repository:', error.message);
    console.log('State file created locally but not persisted to repository');
  }

  // Trigger first task execution using repository dispatch
  if (workflowToken) {
    try {
      await github.rest.repos.createDispatchEvent({
        owner: context.repo.owner,
        repo: context.repo.repo,
        event_type: 'execute-sequential-task',
        client_payload: {
          task_index: 0,
          previous_branch: 'main',
          trigger_source: 'sequential_setup',
          parent_issue: parentIssue
        }
      });
      
      console.log('üöÄ Successfully triggered first task execution');
    } catch (error) {
      console.log('‚ùå Failed to trigger first task execution:', error.message);
      throw new Error('Could not start sequential task execution');
    }
  } else {
    console.log('‚ö†Ô∏è WORKFLOW_TRIGGER_TOKEN not available - cannot trigger first task');
    throw new Error('WORKFLOW_TRIGGER_TOKEN required for sequential execution');
  }

  return {
    tasksCount: tasks.length,
    stateFile: stateFilePath,
    firstTaskTriggered: true
  };
};